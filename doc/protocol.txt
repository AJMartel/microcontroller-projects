Messages originating in the same control loop are batched together provided that the total bytes does not exceed the Xbee packet size of 100 bytes.

COMMAND ( ->)
frame start	1 byte	(0x7e)
length		1 byte  (0x12 = 18 bytes)
cmd		1 byte	(0x43 = C for command)
L / T		4 bytes
T / R		4 bytes
R / P		4 bytes
B / Y		4 bytes
flags		1 bytes
checksum	1 byte

flags are:
0  0x01		attitude command (i.e. armed with attidude)
1  0x02		motor command (i.e. armed with motor)
2  0x04		reset attitude command
3  0x08		calibrate command
4  0x10		RTS tuning (PID & attitude)
4  0x20		RTS telemetry flag (sent with attidude and motor commands)
6  0x40		(unused)
7  0x80		write EEPROM command

note: an attitude command with a throttle of 0 is a kill command

TUNING (<->)
frame start	1 byte	(0x7e)
length		1 byte	(0x27 = 39 bytes)
cmd		1 byte	(0x54 = T for tuning)
type		1 byte  0 = PID, 1 = simple, 2 = complementary, 3 = kalman, 4 = mhv 
payload		36 bytes (9 floats, depends on tuning type)
checksum	1 byte

payloads are
PID:		p.x, i.x, d.x, p.y, i.y, d.y, p.z, i.z, d.z
simple:		time_const
complementary:	k.x, k.y, k.z
kalman:		qangle.x, qangle.y, qgyro.x, qgyro.y, rangle.x, rangle.y
mhv:		gain, beta

TELEMETRY (<- )
frame start	1 byte	(0x7e)
length		1 byte	(0x1e = 30 bytes)
cmd		1 byte	(0x45 = E for tElemetry)
roll (x)	4 bytes
pitch (y)	4 bytes
yaw (z)		4 bytes
motor F		4 bytes
motor B		4 bytes
motor L		4 bytes
motor R		4 bytes
flags		1 byte
checksum	1 byte

flags are:
0  0x01		armed

Length
The length is just the number of bytes in the payload, it does not include the frame start, command, length, or checksum.

Checksum
To calculate: Not including frame delimiters and length, add all bytes keeping only the lowest 8 bits of the result and subtract from 0xFF.
To verify: Add all bytes (include checksum, but not the delimiter and length). If the checksum is correct, the sum will equal 0xFF.

Bytes to be escaped:
0x7e	frame start
0x7d	escape
0x11	xon	(reserved for future flow control)
0x13	xoff	(reserved for future flow control)
To escape a character, insert a 0x7d and follow it with the byte to be escaped xor'd with 0x20.

RANDOM NOTES:
The framing, checksum, and escape mechanism are inspired by the Xbee API mode.

The ideal crystal we should be using for this project i think is 16 MHz.  This matches the XBee clock speed and allows communication at any baud rate without error (the Xbee uses a 16 MHz crystal).  For a link with the PC the rate of 76800 would be the most reliable.  If faster clock speeds on the AVR are beneficial, then 19.6608 MHz or 20.8896 MHz are ideal with a baud rate of 76800.

Setting ATRO=1 with a baud rate of 76800 will mean packetization of messages will happen on a delay of ~0.13 ms.
Setting ATMM=1 (802.15.4 no acks) reduces header size and completely eliminates packet retries at both the 802 layer and the digi layer
The XBee has a packet size of 100 bytes in transparent mode and does not perform any checksum -- so we should definitely add checksums to our messages
After laying out all the packet formats, I can see that combining all messages from a given command loop will not exceed 100 bytes.
100 characters / (76800 / 8) = ~ 13 ms (doesn't account for 802.15.4 headers (18 bytes??) or energy scan retries)
Any time the control requests to send telemetry or pid it should ensure that it does not send more frequently than every 10ms to allow for the return message to be sent.  (I'm assuming that in the field tuning and operation via PC are desirable over the wireless link -- which i think I'd like to have).

comm library requirements

a buffer for the control loop to accumulate outgoing data into

a mailbox slot for each type of incoming message
when a new message is fully received, it is placed into the appropriate slot
the control loop reads values from the slot -- there is no harm in duplicate reads

